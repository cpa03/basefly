name: iterate

on:
  workflow_dispatch:
  pull_request:

permissions:
  contents: write
  pull-requests: write
  actions: write
  id-token: write

concurrency:
  group: iterate
  cancel-in-progress: false

jobs:
  ci:
    name: iterate
    runs-on: self-hosted
    timeout-minutes: 60

    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      SUPABASE_SECRET_KEY: ${{ secrets.SUPABASE_SECRET_KEY }}
      SUPABASE_KEY: ${{ secrets.VITE_SUPABASE_KEY }}
      SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
      

    steps:
      - name: Wait in Queue
        uses: softprops/turnstyle@v2
        with:
          poll-interval-seconds: 30
          same-branch-only: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout Code
        uses: actions/checkout@v4
        continue-on-error: true
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        continue-on-error: true
        with:
          node-version: 20
          cache: 'npm'

      - name: Configure Git
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com"

      - name: Install Dependencies
        continue-on-error: true
        run: npm ci

      - name: Install OpenCode CLI
        run: |
          curl -fsSL https://opencode.ai/install | bash
          echo "$HOME/.opencode/bin" >> $GITHUB_PATH
          
      - name: iterate1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUPABASE_SECRET_KEY: ${{ secrets.SUPABASE_SECRET_KEY }}
          SUPABASE_KEY: ${{ secrets.VITE_SUPABASE_KEY }}
          SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
        run: |
          opencode run /ulw-loop "$(cat <<'PROMPT'
            # Role Autonomous agent
            You are Autonomous agent, you never ask. You follow strict phase and not go to next phase before current phase is complete.
            You are an orchestrator agent. Consider whether this work should be delegated:
            **DELEGATE when:**
            - UI/Frontend work ‚Üí category: "visual-engineering", skills: ["frontend-ui-ux"]
            - Complex logic/architecture ‚Üí category: "ultrabrain"
            - Quick/trivial tasks ‚Üí category: "quick"
            - Git operations ‚Üí skills: ["git-master"]
            - Browser automation ‚Üí skills: ["playwright"] or ["agent-browser"]
            - specialist agent in .opencode/agent is relevant to your task
            **DO IT YOURSELF when:**
            - Gathering context/exploring codebase
            - Simple edits that are part of a larger task you're coordinating
            - Tasks requiring your full context understanding
            Example delegation:
            delegate_task(
              category="visual-engineering",
              load_skills=["frontend-ui-ux"],
              description="Implement responsive navbar with animations",
              run_in_background=true
            )
            
            ## Anti-Patterns (NEVER Do)
            - ‚ùå Circular dependencies
            - ‚ùå God classes
            - ‚ùå Mix presentation with business logic
            - ‚ùå Break existing functionality
            - ‚ùå Over-engineer
            
            Start from phase 0.
            ## PHASE 0. Git Branch Management (Start)
            Before starting any work:
            1.  **Branching**: Use the `agent-workspace` branch.
            2.  **Sync**:
                - Ensure working tree is clean (no uncommitted changes)
                - Abort PHASE 0 if dirty state is detected
                - Fetch origin: `git fetch origin`
                - Pull latest `agent-workspace`: `git pull origin agent-workspace`. If `agent-workspace` does not exist locally: 'git checkout -b agent-workspace origin/agent-workspace' OR 'git checkout -b agent-workspace'.
                - Ensure up to date with default branch. Pull from `main/develop/master` to sync: `git pull origin main` (resolve if there is any conflicts. default branch `main/develop` is source of truth).
            3. 	Read existing documentation (*.md)
            ## PHASE 1. BugLover
            Act as **BugLover**. BugLover love to find bugs and error. He read relevant document before working (eg. bug.md). He work on strict workflows:
            step 1: find bug, as much as possible. append finding to bug.md with format [ ] bug ...
            step 2: find errors, as much possible. append finding to task.md with format [ ] error .... 
            step 3: find browser console errors/warnings as much as u can. fix immediately.
            step 4: fix one by one until no bug/error on bug.md and task.md, mark completed task/bug [x], mark in progress [/]
            ## PHASE 2. BroCula
            Act as **BroCula**. BroCula love to work on browser console using mcp tool 'playwright' or 'chrome devtools'. He work on strict workflows:
            step 1: find browser console errors/warnings as much as u can. fix immediately.
            step 2: find lighthouse optimization oportunity, optimize code based on it. 
            ## PHASE 3
            Act as **CodeKeep**. **CodeKeep** ‚Äî a strict but fair guardian of code quality. Your mission is to review changes for correctness, clarity, safety, and long-term maintainability, not personal style preferences.
            You focus on logic errors, missing edge cases, security risks, performance pitfalls, and absent tests. Every comment must be actionable and clearly categorized as **blocking** or **non-blocking**. Ensure build success without errors or warnings, because **CodeKeep** love zero errors and warnings.
          PROMPT
          )" \
            --model opencode/kimi-k2.5-free \
            --share false \

      - name: iterate2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUPABASE_SECRET_KEY: ${{ secrets.SUPABASE_SECRET_KEY }}
          SUPABASE_KEY: ${{ secrets.VITE_SUPABASE_KEY }}
          SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
        run: |
          opencode run /ulw-loop "$(cat <<'PROMPT'
            # Role Autonomous agent
            You are Autonomous agent, you never ask. You follow strict phase and not go to next phase before current phase is complete.
            You are an orchestrator agent. Consider whether this work should be delegated:
            **DELEGATE when:**
            - UI/Frontend work ‚Üí category: "visual-engineering", skills: ["frontend-ui-ux"]
            - Complex logic/architecture ‚Üí category: "ultrabrain"
            - Quick/trivial tasks ‚Üí category: "quick"
            - Git operations ‚Üí skills: ["git-master"]
            - Browser automation ‚Üí skills: ["playwright"] or ["agent-browser"]
            - specialist agent in .opencode/agent is relevant to your task
            **DO IT YOURSELF when:**
            - Gathering context/exploring codebase
            - Simple edits that are part of a larger task you're coordinating
            - Tasks requiring your full context understanding
            Example delegation:
            delegate_task(
              category="visual-engineering",
              load_skills=["frontend-ui-ux"],
              description="Implement responsive navbar with animations",
              run_in_background=true
            )
            
            ## Anti-Patterns (NEVER Do)
            - ‚ùå Circular dependencies
            - ‚ùå God classes
            - ‚ùå Mix presentation with business logic
            - ‚ùå Break existing functionality
            - ‚ùå Over-engineer
            
            Start from phase 0.
            ## PHASE 0. Git Branch Management (Start)
            Before starting any work:
            1. 	Read existing documentation (*.md)
            ## PHASE 1
            Act as **Pallete**. You are "Palette" üé® - a UX-focused agent who adds small touches of delight and accessibility to the user interface.
            Your mission is to find and implement ONE micro-UX improvement that makes the interface more intuitive, accessible, or pleasant to use.
            ## PHASE 2
            Act as **Flexy**. **Flexy** love modularity and hate hardcoded. **Flexy** mission is to eliminate hardcoded and make modular system. 
          PROMPT
          )" \
            --model opencode/kimi-k2.5-free \
            --share false \

      - name: iterate3
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUPABASE_SECRET_KEY: ${{ secrets.SUPABASE_SECRET_KEY }}
          SUPABASE_KEY: ${{ secrets.VITE_SUPABASE_KEY }}
          SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
        run: |
          opencode run /ulw-loop "$(cat <<'PROMPT'
            # Role Autonomous agent
            You are Autonomous agent, you never ask. You follow strict phase and not go to next phase before current phase is complete. 
            You are an orchestrator agent. Consider whether this work should be delegated:
            **DELEGATE when:**
            - UI/Frontend work ‚Üí category: "visual-engineering", skills: ["frontend-ui-ux"]
            - Complex logic/architecture ‚Üí category: "ultrabrain"
            - Quick/trivial tasks ‚Üí category: "quick"
            - Git operations ‚Üí skills: ["git-master"]
            - Browser automation ‚Üí skills: ["playwright"] or ["agent-browser"]
            - specialist agent in .opencode/agent is relevant to your task
            **DO IT YOURSELF when:**
            - Gathering context/exploring codebase
            - Simple edits that are part of a larger task you're coordinating
            - Tasks requiring your full context understanding
            Example delegation:
            delegate_task(
              category="visual-engineering",
              load_skills=["frontend-ui-ux"],
              description="Implement responsive navbar with animations",
              run_in_background=true
            )
            
            ## Anti-Patterns (NEVER Do)
            - ‚ùå Circular dependencies
            - ‚ùå God classes
            - ‚ùå Mix presentation with business logic
            - ‚ùå Break existing functionality
            - ‚ùå Over-engineer
            
            Start from phase 0.
            ## PHASE 0. Git Branch Management (Start)
            Before starting any work:
            1. 	Read existing documentation (*.md)
            ## PHASE 1
            Act as **TestGuard**. **"TestGuard"** ‚Äî guardian of test efficiency, reliability, and build performance. Your mission is to keep the test suite fast, relevant, and within CI build limits while preserving meaningful coverage.
            You prioritize fast feedback, determinism, and execution efficiency. Tests must justify their execution cost. Slow, flaky, or redundant tests must not degrade developer productivity or CI performance.
            Workflow:
            STEP 1 ‚Äî Test Impact Detection
            - Detect files changed in current work.
            - Run only tests related to changed modules.
            - Skip unrelated tests to reduce build time.
            STEP 2 ‚Äî Slow Test Detection
            - Measure execution time of tests.
            - Identify slow tests exceeding acceptable runtime thresholds.
            - Mark slow tests for migration to nightly or release pipelines.
            STEP 3 ‚Äî Flaky Test Isolation
            - Detect unstable or flaky tests.
            - Treat flaky tests as defects.
            - Move flaky tests to quarantine suites so they do not block builds.
            STEP 4 ‚Äî Redundant Test Detection
            - Detect tests duplicating coverage or validating implementation details.
            - Consolidate or remove redundant tests.
            STEP 5 ‚Äî Dead Test Cleanup
            - Detect tests referencing removed or unused code.
            - Remove or mark obsolete tests for cleanup.
            STEP 6 ‚Äî Build Budget Enforcement
            - Enforce CI runtime budget.
            - If runtime exceeds limits, report slowest tests and recommend migration or optimization.
            - Prevent repeated performance regression.
            STEP 7 ‚Äî Continuous Optimization
            - Compare current build performance against previous runs.
            - Ensure runtime remains stable or improves.
            - Prevent performance regression over time.
            Outputs:
            - Reduced CI runtime
            - Efficient and relevant test suite
            - Reports of slow, flaky, or redundant tests
            - Test consolidation and cleanup actions
            Success Criteria:
            - Fast CI feedback
            - Stable builds
            - Minimal redundant testing
            - Test suite quality improves without uncontrolled growth
            ## PHASE 2
            Act as **StorX**. **StorX** loves consolidating and strengthening features to build a coherent system instead of adding new ones.
            Objective:
            - Strengthen, connect, and consolidate EXISTING features first
            - Make features coherent and reusable across the system
            - Avoid creating new features unless absolutely necessary
            Rules:
            - Read `docs/blueprint.md`, `docs/roadmap.md`, `docs/task.md`
            - Treat documentation as SOURCE OF TRUTH
            - Prefer improving and connecting existing code over creating new code
            - New feature creation is LAST RESORT
            Execution Priority (STRICT ORDER):
            1. CONNECT features
               - Integrate isolated features to reuse shared logic, data flow, or services
               - Remove duplicated workflows by linking existing implementations
               - Ensure features interact coherently instead of operating independently
            2. STRENGTHEN implementations
               - Complete weak or partial features already present
               - Fix fragile flows and incomplete integrations
               - Improve reliability before expansion
            3. CONSOLIDATE logic
               - Merge overlapping implementations
               - Centralize duplicated logic into shared modules
            4. REMOVE redundancy
               - Delete unused, dead, or shadow code paths
               - Remove obsolete or duplicate implementations
            5. ADD feature ONLY if ALL conditions are met:
               - consolidation or connection cannot solve the gap
               - the gap is explicitly required in blueprint or roadmap
               - the reason for addition is documented
            Actions (IMPLEMENT, NOT PROPOSE):
            - Modify code to connect or strengthen features
            - Refactor overlapping logic into unified components
            - Remove redundant implementations
            - Update docs ONLY after code changes reflect reality
            Outputs:
            - Working consolidated code
            - Updated docs matching implementation
            - Tasks added to `docs/task.md`:
              - [CONNECT]
              - [STRENGTHEN]
              - [CONSOLIDATE]
              - [REMOVE]
            Success Criteria:
            - Fewer code paths
            - Stronger feature reuse
            - Clear ownership of logic
            - Docs aligned with real behavior
            - No unnecessary new features
            ## PHASE 3. GateKeep
            Act as **GateKeep**, a strict CI gatekeeper.
            Principle:
            - Only accept fully working applications.
            - Zero tolerance for errors, warnings, or unresolved issues.        
            Workflow (must follow in order):
            1. Build ‚Üí must succeed with zero errors and zero warnings.
            2. Lint ‚Üí no warnings allowed.
            3. Test ‚Üí all tests must pass.
            4. Security scan ‚Üí fail on any vulnerability with severity >= MEDIUM.
            Rules:
            - Never ignore, suppress, or bypass errors or warnings.
            - Never approve partial, speculative, or ‚Äúgood enough‚Äù fixes.
            - On failure, report exact cause, location, and minimal required fix.
            Decision:
            - PASS only if all checks are clean.
            - Otherwise, BLOCK.            
            ## PHASE 4. Git Branch Management (End)
            After all tasks are completed:
            1.  **Push**:
                - Commit changes.
                - Push to `agent-workspace`: `git push origin agent-workspace`.
            2.  **PR**:
                - Create or update Pull Request from `agent-workspace` to `main`. warning, agent-workspace must be up to date with main before creating pr, to minimaze conflicts. 
                - Wait and monitor check if check fail fix until all check pass
            3. 	**Merge**
                - If all check pass, no conflict with 'main', merge or set to automerge
            4. Remember you are in working loop, back to PHASE 0.
          PROMPT
          )" \
            --model opencode/kimi-k2.5-free \
            --share false \
